{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Compose Stability Analyzer provides real-time analysis of your Jetpack Compose composable functions' stability directly within Android Studio or IntelliJ. It helps you understand why a composable function is stable or unstable, and offers detailed insights through recomposition tracing and logging.</p> <p>Instantly see which composable parameters cause unnecessary recompositions right in your IDE, and automatically catch stability regressions in CI before they reach production.</p> <p></p>"},{"location":"#key-features","title":"Key Features","text":"<p>The Compose Stability Analyzer equips you with visual and analytical tools across your entire development workflow. Gutter Icons place colored dots in the editor margin so you can see at a glance whether a composable is skippable. Hover Tooltips provide detailed stability breakdowns (including the specific reason each parameter is stable or unstable) when you hover over any composable function. Inline Parameter Hints go even further, placing badges next to each parameter so you can read stability information without leaving the code.</p> <p>Beyond visual feedback, the plugin includes Code Inspections that actively suggest improvements with quick fixes, and a Stability Explorer that gives you a project-wide tree view of all composables organized by module, package, and file. For runtime analysis, the <code>@TraceRecomposition</code> annotation lets you trace exactly which parameters change during recomposition, and the <code>stabilityDump</code>/<code>stabilityCheck</code> Gradle tasks bring CI-ready stability validation to prevent regressions from reaching production.</p>"},{"location":"#two-components","title":"Two Components","text":"<p>Compose Stability Analyzer consists of two independent, complementary components. The IDE Plugin provides visual stability indicators (gutter icons, tooltips, inline hints, inspections, and the Stability Explorer) directly in Android Studio. You install it from the JetBrains Marketplace and it works immediately with no build configuration changes.</p> <p>The Gradle Plugin operates at build time and runtime. It powers the <code>@TraceRecomposition</code> annotation for runtime recomposition logging, and provides the <code>stabilityDump</code>/<code>stabilityCheck</code> tasks for CI-ready stability validation. You add it to your <code>build.gradle.kts</code>.</p> Component Purpose Integration IDE Plugin Visual stability indicators directly in Android Studio Install from JetBrains Marketplace Gradle Plugin Runtime recomposition tracing and stability validation Add to your <code>build.gradle.kts</code> <p>Independence</p> <p>The IDE plugin and Gradle plugin are completely independent. You can use either one alone, or both together for the full experience.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#ide-plugin","title":"IDE Plugin","text":"<p>Open Android Studio &gt; Settings &gt; Plugins &gt; Marketplace &gt; search Compose Stability Analyzer &gt; Install</p> <p></p>"},{"location":"#gradle-plugin","title":"Gradle Plugin","text":"<p>Add the plugin to <code>libs.versions.toml</code>:</p> <pre><code>[plugins]\nstability-analyzer = { id = \"com.github.skydoves.compose.stability.analyzer\", version = \"$version\" }\n</code></pre> <p>Apply to your root <code>build.gradle.kts</code>:</p> <pre><code>alias(libs.plugins.stability.analyzer) apply false\n</code></pre> <p>Apply to your app or module's <code>build.gradle.kts</code>:</p> <pre><code>alias(libs.plugins.stability.analyzer)\n</code></pre>"},{"location":"#why-use-this","title":"Why Use This?","text":"<p>Jetpack Compose's declarative paradigm brings hidden complexity: understanding recomposition behavior. When a composable recomposes unnecessarily, you pay a performance cost: CPU cycles spent re-rendering UI that didn't actually change.</p> <p>The challenge isn't just identifying these issues; it's understanding why they happen. A composable might recompose because a parameter changed, because a parameter is unstable, or because a parent recomposed and the composable couldn't be skipped. Without tooling, diagnosing the root cause means adding manual logging, reading compiler metrics reports, or guessing.</p> <p>Compose Stability Analyzer bridges this gap by giving you real-time visibility into stability at every level: from parameter hints in your editor to CI-enforced regression checks. Instead of discovering performance issues after they've shipped, you catch them the moment they're introduced.</p> <p>Not about making everything stable</p> <p>You don't need to make every composable function skippable or all parameters stable. These are not direct indicators of performance optimization. The goal of this plugin is to help you explore how Compose's stability mechanisms work and use them as tools for examining and debugging composables that may have performance issues.</p>"},{"location":"sponsor/","title":"Sponsor","text":"<p>The sponsors listed below made it possible for this project to be released as open source. Many thanks to all of them for their support!</p>"},{"location":"sponsor/#vision-agents","title":"Vision Agents","text":"<p>Vision Agents is an open-source Video AI framework for building real-time voice and video applications. The framework is edge/transport agnostic, meaning developers can also bring any edge layer they like.</p>"},{"location":"sponsor/#coderabbit","title":"CodeRabbit","text":"<p>CodeRabbit is an AI-powered code review platform that integrates directly into pull-request workflows and IDEs, examining code changes in context and suggesting improvements.</p>"},{"location":"sponsor/#firebender","title":"Firebender","text":"<p>Firebender is the most powerful AI coding agent in Android Studio. It can create entire compose UIs from Figma links, generate UML diagrams, and even understand your voice input.</p>"},{"location":"sponsor/#support-this-project","title":"Support This Project","text":"<p>If you find this library useful, support it by:</p> <ul> <li>Joining stargazers for this repository</li> <li>Following skydoves on GitHub</li> </ul>"},{"location":"sponsor/#license","title":"License","text":"<pre><code>Designed and developed by 2025 skydoves (Jaewoong Eum)\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"stability-concepts/","title":"Stability Concepts","text":"<p>Understanding how Compose stability works is key to writing performant composable functions. This page explains the core concepts that the Compose Stability Analyzer helps you visualize and debug.</p>"},{"location":"stability-concepts/#what-is-stability","title":"What Is Stability?","text":"<p>In Jetpack Compose, stability refers to whether the Compose compiler can guarantee that a type's value will not change between recompositions. This guarantee is central to Compose's performance model: when the compiler knows a parameter is stable, it can safely skip re-executing a composable function if the parameter's value hasn't changed since the last composition. This skipping mechanism is one of the most important performance optimizations in Compose.</p> <pre><code>// STABLE: all properties are val and primitive/stable types\ndata class User(val name: String, val age: Int)\n\n// UNSTABLE: has mutable property\ndata class MutableUser(var name: String, var age: Int)\n</code></pre> <p>The <code>User</code> class is stable because the compiler can see that both properties are <code>val</code> (read-only) and their types (<code>String</code>, <code>Int</code>) are themselves stable. The <code>MutableUser</code> class is unstable because <code>var</code> properties can be changed after construction, so the compiler can't guarantee the value will be the same between recompositions.</p>"},{"location":"stability-concepts/#stable-vs-unstable-types","title":"Stable vs Unstable Types","text":""},{"location":"stability-concepts/#stable-types","title":"Stable Types","text":"<p>The Compose compiler considers a type stable when it can prove the type's public state won't change after construction. Primitive types (<code>Int</code>, <code>String</code>, <code>Float</code>, <code>Boolean</code>) are always stable because they're immutable by nature. Data classes with only <code>val</code> properties of stable types are also stable, since the compiler can verify this by inspecting the class definition. Types explicitly annotated with <code>@Stable</code> or <code>@Immutable</code> are treated as stable because the developer has made a contract with the compiler that the type behaves stably.</p> Type Stable? Reason <code>String</code> Yes Primitive/immutable <code>Int</code>, <code>Float</code>, <code>Boolean</code> Yes Primitive <code>data class Foo(val x: Int)</code> Yes Immutable properties of stable types <code>List&lt;String&gt;</code> Depends <code>kotlin.collections.List</code> is an interface, so stability depends on the Compose compiler version and strong skipping mode <code>MutableList&lt;String&gt;</code> No Mutable collection <code>data class Bar(var x: Int)</code> No Mutable property"},{"location":"stability-concepts/#unstable-types","title":"Unstable Types","text":"<p>A type becomes unstable when the compiler can't guarantee immutability. The most common cause is <code>var</code> properties; even a single <code>var</code> in a data class makes the entire type unstable. Mutable collections (<code>MutableList</code>, <code>MutableMap</code>, <code>MutableSet</code>) are always unstable because their contents can change at any time.</p> <p>Types that contain properties of unstable types are themselves unstable, because instability propagates upward. A <code>data class Order(val items: MutableList&lt;Item&gt;)</code> is unstable even though <code>items</code> is <code>val</code>, because <code>MutableList</code> itself is mutable.</p> <p>Types from external modules that were not compiled with the Compose compiler are also treated as unstable by default, because the compiler has no way to inspect their stability. This is a common source of unexpected instability in multi-module projects.</p>"},{"location":"stability-concepts/#skippability-and-restartability","title":"Skippability and Restartability","text":""},{"location":"stability-concepts/#skippable","title":"Skippable","text":"<p>A composable is skippable when Compose can skip its execution entirely if all parameters are stable and unchanged since the last composition. This is the primary performance benefit of stability. During recomposition, Compose checks each parameter and, if nothing has changed, avoids re-executing the function body entirely.</p> <pre><code>// Skippable: all parameters are stable\n@Composable\nfun UserCard(name: String, age: Int) {\n    Text(\"$name, $age\")\n}\n</code></pre> <p>When <code>UserCard</code> is called during recomposition, Compose checks whether <code>name</code> and <code>age</code> have the same values as the previous composition. If they do, the entire function is skipped: no <code>Text</code> calls, no layout, no rendering. This adds up quickly in lists or complex UIs where many composables might not need updating.</p>"},{"location":"stability-concepts/#non-skippable","title":"Non-Skippable","text":"<p>A composable is non-skippable when it has at least one unstable parameter. Because the compiler can't guarantee the parameter's value is unchanged, Compose must always re-execute the function during recomposition, even if the values happen to be identical.</p> <pre><code>// Non-skippable: List&lt;Product&gt; may be unstable\n@Composable\nfun ProductList(items: List&lt;Product&gt;) {\n    items.forEach { Text(it.name) }\n}\n</code></pre> <p>This doesn't mean the composable has a performance problem. It depends on how often the parent recomposes and how expensive the function body is. But it does mean Compose can't optimize this composable, so it's worth investigating if you notice performance issues.</p>"},{"location":"stability-concepts/#restartable","title":"Restartable","text":"<p>A composable is restartable when Compose can independently restart its execution when state it reads changes. Most composables are restartable. The distinction matters because a composable that is restartable but not skippable will always re-execute when its parent recomposes. It can restart independently but can never be skipped.</p>"},{"location":"stability-concepts/#recomposition","title":"Recomposition","text":"<p>Recomposition is the process of Compose re-executing composable functions when the data they depend on changes. Compose's runtime is designed to be efficient about this. It tracks which composables read which state, and when state changes, it only re-executes the composables that actually depend on that state.</p> <p>Within a recomposition, Compose applies three optimizations. First, it only recomposes functions whose inputs have changed; if a composable's parameters are the same, there's no reason to re-execute it. Second, it skips functions where all parameters are stable and unchanged (this is the skippability optimization). Third, it restarts only the smallest scope necessary, so a state change deep in the UI tree doesn't trigger recomposition of the entire tree.</p>"},{"location":"stability-concepts/#unnecessary-recompositions","title":"Unnecessary Recompositions","text":"<p>When a composable has unstable parameters, Compose's second optimization (skipping) is disabled for that composable. The result is unnecessary recompositions: the composable re-executes even when its parameters haven't actually changed.</p> <pre><code>// This recomposes every time the parent recomposes,\n// even if the user object hasn't actually changed\n@Composable\nfun UserCard(user: MutableUser) {  // MutableUser is unstable\n    Text(user.name)\n}\n</code></pre> <p>In isolation, a single unnecessary recomposition is rarely noticeable. But in a <code>LazyColumn</code> with 50 items, or in a screen with deeply nested composables, the cumulative cost of re-executing functions that don't need to run can cause visible jank: dropped frames, sluggish scrolling, or delayed response to user input.</p>"},{"location":"stability-concepts/#fixing-instability","title":"Fixing Instability","text":""},{"location":"stability-concepts/#use-val-instead-of-var","title":"Use <code>val</code> Instead of <code>var</code>","text":"<p>The most common and simplest fix is making properties immutable. If a property doesn't need to be mutable after construction, use <code>val</code> instead of <code>var</code>. This single change is often enough to make a type stable.</p> <pre><code>// Before (UNSTABLE)\ndata class Product(var name: String, var price: Double)\n\n// After (STABLE)\ndata class Product(val name: String, val price: Double)\n</code></pre>"},{"location":"stability-concepts/#use-stable-or-immutable","title":"Use <code>@Stable</code> or <code>@Immutable</code>","text":"<p>For types where the compiler can't infer stability but you know the type behaves stably, you can add the <code>@Stable</code> or <code>@Immutable</code> annotation. <code>@Immutable</code> is the stronger contract: it promises that all public properties will never change after construction. <code>@Stable</code> is more permissive, promising that if a public property changes, the composition will be notified (via Compose's snapshot system).</p> <pre><code>@Stable\nclass UserRepository(private val api: UserApi) {\n    // Even though UserApi might be unstable,\n    // you're guaranteeing this class behaves stably\n}\n\n@Immutable\ndata class Theme(val primary: Color, val secondary: Color)\n</code></pre> <p>@Stable is a contract</p> <p><code>@Stable</code> and <code>@Immutable</code> are promises to the compiler. If you annotate a type as stable but mutate it outside of Compose's snapshot system, you may get incorrect UI behavior. Compose will skip recompositions that should happen, resulting in stale UI.</p>"},{"location":"stability-concepts/#use-immutable-collections","title":"Use Immutable Collections","text":"<p>Standard Kotlin collections (<code>List</code>, <code>Map</code>, <code>Set</code>) are interfaces, and the compiler can't guarantee that the underlying implementation is immutable. Replacing them with immutable alternatives from <code>kotlinx.collections.immutable</code> gives the compiler the guarantee it needs.</p> <pre><code>// Before (UNSTABLE)\n@Composable\nfun ItemList(items: MutableList&lt;Item&gt;) { ... }\n\n// After (STABLE with kotlinx.collections.immutable)\n@Composable\nfun ItemList(items: ImmutableList&lt;Item&gt;) { ... }\n</code></pre>"},{"location":"stability-concepts/#stability-configuration-file","title":"Stability Configuration File","text":"<p>For types you can't modify (third-party library classes, generated code, or Java types), you can create a stability configuration file that tells the Compose compiler to treat specific types as stable. This is a project-level solution that doesn't require modifying the source of the types themselves.</p> <pre><code>// stability-config.txt\ncom.example.ThirdPartyModel\ncom.google.firebase.auth.FirebaseUser\n</code></pre>"},{"location":"stability-concepts/#cross-module-stability","title":"Cross-Module Stability","text":"<p>Types from other modules that were not compiled with the Compose compiler are treated as unstable by default. This is a conservative decision, because the Compose compiler in your module can't inspect the source code of external modules, so it can't verify stability.</p> <p>The <code>@StabilityInferred</code> annotation helps resolve this. When a class is compiled with the Compose compiler, this annotation is automatically added to the class's bytecode, recording whether the compiler inferred it as stable. When another module encounters this class as a parameter type, it reads the <code>@StabilityInferred</code> annotation to determine stability without needing access to the source code.</p> <p>This mechanism is transparent: you don't need to add the annotation manually. It's added automatically by the Compose compiler during compilation. However, it only works for modules that are compiled with the Compose compiler; modules compiled with plain <code>kotlinc</code> won't have this annotation.</p>"},{"location":"stability-concepts/#strong-skipping-mode","title":"Strong Skipping Mode","text":"<p>Strong Skipping Mode (introduced in Compose Compiler 1.5.4+ and enabled by default in newer versions) relaxes the stability requirements for skipping. In standard mode, a composable can only be skipped if all parameters are stable and unchanged. In Strong Skipping mode, unstable parameters are compared using instance equality (<code>===</code>), so if the exact same object instance is passed, the composable can still be skipped.</p> <p>This means more composables become skippable in practice, because even unstable parameters can be skipped if the same instance is reused. Lambda parameters are also automatically remembered in Strong Skipping mode, eliminating a common source of unnecessary recomposition.</p> <p>With Strong Skipping Mode enabled, the stability of individual parameters matters less for skippability. However, understanding stability is still valuable for debugging performance issues. If a composable is recomposing excessively, knowing whether parameters are stable helps you understand whether the issue is a genuinely changing value or an unnecessarily recreated object.</p>"},{"location":"stability-concepts/#how-the-analyzer-helps","title":"How the Analyzer Helps","text":"<p>The Compose Stability Analyzer provides tools at every stage of your development workflow. The IDE Plugin gives you real-time feedback while coding. Gutter icons, tooltips, and inline hints show stability information as you write, so you can catch issues before they're even committed.</p> <p>The <code>@TraceRecomposition</code> annotation operates at runtime, logging detailed recomposition events that show you exactly which parameters changed and which are unstable. This is invaluable for diagnosing performance issues in running apps, where static analysis alone can't capture the full picture.</p> <p>The <code>stabilityCheck</code> Gradle task runs in CI/CD, comparing your current code against a baseline and failing the build if stability has regressed. This prevents regressions from reaching production and creates a documented history of stability decisions in your git log.</p> Tool When What It Shows IDE Plugin While coding Gutter icons, tooltips, inline hints showing stability <code>@TraceRecomposition</code> At runtime Logs showing which parameters caused recomposition <code>stabilityCheck</code> In CI/CD Detects stability regressions before they reach production <p>Together, these tools give you complete visibility into your composables' stability, from writing code to shipping it.</p>"},{"location":"version-map/","title":"Kotlin Version Map","text":"<p>It is strongly recommended to use the exact same Kotlin version as this library. Using a different Kotlin version may lead to compilation errors during the build process.</p>"},{"location":"version-map/#version-compatibility","title":"Version Compatibility","text":"Stability Analyzer Kotlin 0.6.5+ 2.3.0 0.4.0 ~ 0.6.4 2.2.21 <p>Version mismatch</p> <p>The Compose Stability Analyzer compiler plugin is tightly coupled to the Kotlin compiler version. If your project uses a different Kotlin version, you may see errors like:</p> <pre><code>e: This version of the Compose Stability Analyzer compiler plugin\n   requires Kotlin version X.X.X but you are using Y.Y.Y\n</code></pre> <p>Upgrade or downgrade the plugin version to match your Kotlin version.</p>"},{"location":"version-map/#compose-compiler-compatibility","title":"Compose Compiler Compatibility","text":"<p>The Compose Stability Analyzer works alongside the Compose compiler. Ensure your Compose compiler version is compatible with your Kotlin version:</p> Kotlin Compose Compiler 2.3.0 Bundled with Kotlin 2.2.21 Bundled with Kotlin <p>Compose Compiler bundled with Kotlin</p> <p>Starting with Kotlin 2.0, the Compose compiler is bundled as a Kotlin compiler plugin. You no longer need to specify a separate Compose compiler version; it is automatically matched to your Kotlin version.</p>"},{"location":"version-map/#maven-coordinates","title":"Maven Coordinates","text":"<pre><code>// Gradle plugin\nid(\"com.github.skydoves.compose.stability.analyzer\") version \"$version\"\n\n// Runtime (added automatically by the Gradle plugin)\nimplementation(\"com.github.skydoves:compose-stability-runtime:$version\")\n</code></pre>"},{"location":"gradle-plugin/ci-cd/","title":"CI/CD Integration","text":"<p>Adding stability validation to your CI pipeline ensures that every pull request is automatically checked for stability regressions. This creates a safety net that catches performance-impacting changes before they're merged, without requiring manual review of stability reports.</p>"},{"location":"gradle-plugin/ci-cd/#github-actions","title":"GitHub Actions","text":"<p>The following workflow runs stability validation on every push and pull request. It's split into two jobs: <code>build</code> compiles the project, and <code>stability_check</code> runs the validation after compilation completes.</p> <pre><code>name: Android CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up JDK 21\n        uses: actions/setup-java@v4\n        with:\n          java-version: '21'\n          distribution: 'zulu'\n      - name: Build project\n        run: ./gradlew :app:compileDebugKotlin\n\n  stability_check:\n    name: Compose Stability Check\n    runs-on: ubuntu-latest\n    needs: build\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up JDK 21\n        uses: actions/setup-java@v4\n        with:\n          java-version: '21'\n          distribution: 'zulu'\n      - name: Run stability check\n        run: ./gradlew stabilityCheck\n</code></pre> <p>The <code>needs: build</code> dependency is critical because it ensures that compilation has finished before the stability check runs. The stability analysis reads compiled output, so running it before compilation would produce incorrect results or fail.</p> <p>Build order matters</p> <p>The stability check must run after compilation. The <code>needs: build</code> dependency ensures this. If you combine both steps into a single job, make sure <code>compileDebugKotlin</code> runs before <code>stabilityCheck</code>.</p>"},{"location":"gradle-plugin/ci-cd/#workflow-for-teams","title":"Workflow for Teams","text":""},{"location":"gradle-plugin/ci-cd/#initial-setup","title":"Initial Setup","text":"<p>Getting stability validation running for the first time requires four steps. First, add the Gradle plugin to your project following the Getting Started guide. Then run <code>./gradlew stabilityDump</code> to create the baseline. This captures the current stability state of all your composables as the \"known good\" reference point.</p> <p>Commit the generated <code>.stability</code> files to your repository. These files are intentionally human-readable so they can be reviewed in pull requests. Finally, add the <code>stabilityCheck</code> task to your CI pipeline using the GitHub Actions workflow above (or its equivalent for your CI system).</p> <p>From this point forward, every pull request will be automatically validated against the baseline.</p>"},{"location":"gradle-plugin/ci-cd/#day-to-day-development","title":"Day-to-Day Development","text":"<p>Once the CI pipeline is configured, the workflow is transparent to developers. A developer makes code changes and opens a pull request. CI automatically runs <code>stabilityCheck</code> on the PR. If all composables maintain their stability (or improve), the check passes silently and the PR can be merged.</p> <p>If a change causes a stability regression (for example, changing a <code>val</code> to <code>var</code> in a data class that's used as a composable parameter), the CI check fails with a clear message showing exactly which composables were affected and how their stability changed. The developer then has two options: fix the regression (the preferred path), or update the baseline if the stability change is intentional and justified.</p>"},{"location":"gradle-plugin/ci-cd/#updating-the-baseline","title":"Updating the Baseline","text":"<p>When a stability change is intentional (perhaps you're adding a mutable property that's genuinely needed, or you're refactoring a data model in a way that temporarily reduces stability), you update the baseline by running <code>stabilityDump</code> again and committing the updated file.</p> <pre><code>./gradlew :app:compileDebugKotlin\n./gradlew :app:stabilityDump\ngit add app/stability/app.stability\ngit commit -m \"Update stability baseline: justified by [reason]\"\n</code></pre> <p>This creates a deliberate, documented decision in git history. Anyone looking at the commit log can see when stability changed, what changed, and (from the commit message) why it was accepted. This is far more valuable than silently accumulating regressions over time.</p>"},{"location":"gradle-plugin/ci-cd/#different-behavior-per-environment","title":"Different Behavior Per Environment","text":"<p>A common pattern is to run stability validation in strict mode on CI (where regressions should block the build) but in warning-only mode during local development (where developers want to see stability information without being blocked while iterating).</p> <pre><code>composeStabilityAnalyzer {\n    stabilityValidation {\n        // Strict mode on CI, warning mode locally\n        failOnStabilityChange.set(System.getenv(\"CI\") == \"true\")\n    }\n}\n</code></pre> <p>This configuration reads the <code>CI</code> environment variable, which is automatically set to <code>\"true\"</code> by GitHub Actions, GitLab CI, CircleCI, and most other CI systems. Locally, the variable is unset, so <code>failOnStabilityChange</code> defaults to <code>false</code> and stability changes produce warnings instead of build failures.</p>"},{"location":"gradle-plugin/ci-cd/#quick-integration-example","title":"Quick Integration Example","text":"<p>For a real-world example of integrating stability validation into an existing project, see the Landscapist integration PR. This PR shows the complete setup (plugin configuration, baseline generation, and CI workflow) applied to a production open-source project.</p>"},{"location":"gradle-plugin/custom-logger/","title":"Custom Logger","text":"<p>By default, <code>@TraceRecomposition</code> logs recomposition events to Logcat using Android's <code>Log.d()</code>. You can completely replace this behavior by implementing your own <code>RecompositionLogger</code>. This is useful when you want to format logs differently, send analytics events, or integrate with your existing logging infrastructure.</p>"},{"location":"gradle-plugin/custom-logger/#setting-a-custom-logger","title":"Setting a Custom Logger","text":"<p>To override the default logging behavior, call <code>ComposeStabilityAnalyzer.setLogger()</code> with your own <code>RecompositionLogger</code> implementation. The <code>log()</code> method receives a <code>RecompositionEvent</code> containing everything about the recomposition: which composable, how many times, which parameters changed, and which are unstable.</p> <pre><code>ComposeStabilityAnalyzer.setLogger(object : RecompositionLogger {\n    override fun log(event: RecompositionEvent) {\n        val message = buildString {\n            append(\"Recomposition #${event.recompositionCount}\")\n            append(\" - ${event.composableName}\")\n            if (event.tag.isNotEmpty()) {\n                append(\" [${event.tag}]\")\n            }\n            appendLine()\n\n            event.parameterChanges.forEach { change -&gt;\n                append(\"  ${change.name}: ${change.type}\")\n                when {\n                    change.changed -&gt; append(\" CHANGED\")\n                    change.stable -&gt; append(\" STABLE\")\n                    else -&gt; append(\" UNSTABLE\")\n                }\n                appendLine()\n            }\n        }\n\n        Log.d(\"CustomRecomposition\", message)\n    }\n})\n</code></pre> <p>In this example, the logger builds a human-readable message that includes:</p> <ul> <li>The recomposition count and composable name</li> <li>The tag (if one was set via <code>@TraceRecomposition(tag = \"...\")</code>)</li> <li>Each parameter's name, type, and whether it changed, is stable, or is unstable</li> </ul> <p>You can place this call in your <code>Application.onCreate()</code> alongside <code>ComposeStabilityAnalyzer.setEnabled()</code>.</p>"},{"location":"gradle-plugin/custom-logger/#firebase-analytics-integration","title":"Firebase Analytics Integration","text":"<p>One of the most powerful use cases for a custom logger is tracking excessive recompositions in production. By sending recomposition data to Firebase Analytics (or any analytics platform), you can identify performance hotspots in real user sessions, not just during local development.</p> <p>The example below sends a Firebase event whenever a composable recomposes 10 or more times. This threshold filters out normal recompositions (initial layout, expected state changes) and only captures composables that are recomposing excessively, which often indicates a stability problem.</p> <pre><code>ComposeStabilityAnalyzer.setLogger(object : RecompositionLogger {\n    override fun log(event: RecompositionEvent) {\n        if (event.recompositionCount &gt;= 10) {\n            FirebaseAnalytics.getInstance(context).logEvent(\"excessive_recomposition\") {\n                param(\"tag\", event.tag)\n                param(\"composable\", event.composableName)\n                param(\"count\", event.recompositionCount.toLong())\n                param(\"unstable_params\", event.unstableParameters.joinToString())\n            }\n        }\n    }\n})\n</code></pre> <p>Choosing a threshold</p> <p>The threshold of <code>10</code> is a starting point. Adjust it based on your app's behavior. List items or frequently updating screens may need a higher threshold (e.g., <code>20</code> or <code>50</code>), while static screens should rarely exceed <code>3</code>.</p> <p>With this data flowing into Firebase, you can:</p> <ul> <li>Create dashboards showing which composables recompose most across your user base</li> <li>Set up alerts when a composable exceeds a recomposition threshold</li> <li>Track whether stability fixes reduce recomposition counts over time</li> <li>Correlate excessive recompositions with user-reported performance issues</li> </ul>"},{"location":"gradle-plugin/custom-logger/#tag-based-filtering","title":"Tag-Based Filtering","text":"<p>Tags (set via <code>@TraceRecomposition(tag = \"...\")</code>) let you categorize composables by feature or screen. A tag-based logger uses these tags to route events differently; for example, sending analytics for specific features while logging everything else to Logcat during development.</p> <p>This pattern is especially useful in large apps where you want to monitor critical flows (checkout, authentication, feed) in production without the noise from every composable in the app.</p> <pre><code>val tagsToLog = setOf(\"user-profile\", \"checkout\", \"performance\")\n\nComposeStabilityAnalyzer.setLogger(object : RecompositionLogger {\n    override fun log(event: RecompositionEvent) {\n        if (!BuildConfig.DEBUG) {\n            if (event.tag in tagsToLog || event.tag.isEmpty()) {\n                // Send to analytics in release mode\n                FirebaseAnalytics.getInstance(context).logEvent(\"recomposition\") {\n                    param(\"tag\", event.tag)\n                    param(\"composable\", event.composableName)\n                    param(\"count\", event.recompositionCount.toLong())\n                }\n            }\n        } else {\n            // Log everything in debug mode\n            Log.d(\"Recomposition\", \"${event.composableName}: #${event.recompositionCount}\")\n        }\n    }\n})\n</code></pre> <p>How this works:</p> <ul> <li>In release builds (<code>!BuildConfig.DEBUG</code>): Only composables with tags in the <code>tagsToLog</code> set (or untagged composables) send events to Firebase. This keeps analytics focused on the features you care about.</li> <li>In debug builds: Every recomposition is logged to Logcat regardless of tag, giving you full visibility during development.</li> </ul> <p>You can update the <code>tagsToLog</code> set as your monitoring needs change: add new tags when investigating a performance issue, remove them once the issue is resolved.</p>"},{"location":"gradle-plugin/custom-logger/#recompositionevent-fields","title":"RecompositionEvent Fields","text":"<p>The <code>RecompositionEvent</code> object passed to your logger contains all the information about a recomposition. Here is a reference of all available fields:</p> Field Type Description <code>composableName</code> <code>String</code> Name of the composable function that recomposed <code>tag</code> <code>String</code> Tag from <code>@TraceRecomposition(tag = \"...\")</code>. Empty string if no tag was set <code>recompositionCount</code> <code>Int</code> How many times this composable instance has recomposed (starts at 1) <code>parameterChanges</code> <code>List&lt;ParameterChange&gt;</code> Detailed information about each parameter: its name, type, whether it changed, and whether it is stable <code>unstableParameters</code> <code>List&lt;String&gt;</code> Convenience list of parameter names that are unstable. Useful for quick checks without iterating <code>parameterChanges</code> <p>Each <code>ParameterChange</code> in the <code>parameterChanges</code> list contains:</p> Field Type Description <code>name</code> <code>String</code> Parameter name <code>type</code> <code>String</code> Parameter type (e.g., <code>User</code>, <code>String</code>, <code>List&lt;Product&gt;</code>) <code>changed</code> <code>Boolean</code> Whether this parameter's value changed since the last composition <code>stable</code> <code>Boolean</code> Whether the Compose compiler considers this parameter stable"},{"location":"gradle-plugin/custom-logger/#filtering-logcat","title":"Filtering Logcat","text":"<p>When using the default logger (without setting a custom one), recomposition events are logged to Logcat with the tag <code>Recomposition</code>. You can filter Logcat to find specific information:</p> <ul> <li>All recompositions: Filter by <code>Recomposition</code></li> <li>Tagged recompositions: Filter by <code>tag: &lt;tag name&gt;</code> (e.g., <code>tag: user-profile</code>)</li> <li>Specific composable: Filter by the composable name (e.g., <code>ProductCard</code>) combined with <code>Recomposition</code></li> <li>Unstable parameters: Filter by <code>Unstable parameters:</code> to find composables with stability issues</li> </ul>"},{"location":"gradle-plugin/getting-started/","title":"Getting Started","text":"<p>The Compose Stability Analyzer Gradle plugin enables runtime recomposition tracing with the <code>@TraceRecomposition</code> annotation and stability validation for CI/CD pipelines. It works as a Kotlin compiler plugin that instruments your composable functions at compile time, and this plugin supports Kotlin Multiplatform.</p> <p></p>"},{"location":"gradle-plugin/getting-started/#installation","title":"Installation","text":""},{"location":"gradle-plugin/getting-started/#step-1-add-to-version-catalog","title":"Step 1: Add to Version Catalog","text":"<p>Add the plugin to the <code>[plugins]</code> section of your <code>libs.versions.toml</code> file. This registers the plugin so it can be referenced by alias in your build scripts.</p> <pre><code>[plugins]\nstability-analyzer = { id = \"com.github.skydoves.compose.stability.analyzer\", version = \"$version\" }\n</code></pre>"},{"location":"gradle-plugin/getting-started/#step-2-apply-to-root-project","title":"Step 2: Apply to Root Project","text":"<p>Apply the plugin to your root <code>build.gradle.kts</code> with <code>apply false</code>. This makes the plugin available to submodules without applying it to the root project itself, which is a standard Gradle convention for plugins that should only run in specific modules.</p> <pre><code>plugins {\n    alias(libs.plugins.stability.analyzer) apply false\n}\n</code></pre>"},{"location":"gradle-plugin/getting-started/#step-3-apply-to-your-module","title":"Step 3: Apply to Your Module","text":"<p>Apply the plugin to each app or shared module's <code>build.gradle.kts</code> where you want recomposition tracing or stability validation. When applied, the plugin automatically adds the compiler plugin to Kotlin compilation tasks and includes the runtime library as a dependency.</p> <pre><code>plugins {\n    alias(libs.plugins.stability.analyzer)\n}\n</code></pre> <p>Sync your project to complete the setup. The plugin is now active and will instrument your composable functions during compilation.</p>"},{"location":"gradle-plugin/getting-started/#kotlin-version-mapping","title":"Kotlin Version Mapping","text":"<p>The Compose Stability Analyzer compiler plugin is tightly coupled to the Kotlin compiler version because it extends the compiler's internal APIs. Using a mismatched Kotlin version may lead to compilation errors. It is strongly recommended to use the exact same Kotlin version as this library.</p> Stability Analyzer Kotlin 0.6.5+ 2.3.0 0.4.0 ~ 0.6.4 2.2.21"},{"location":"gradle-plugin/getting-started/#whats-included","title":"What's Included","text":"<p>The Gradle plugin provides four capabilities that work together. The <code>@TraceRecomposition</code> annotation is added to any composable function you want to monitor. At runtime, it logs detailed information about each recomposition event, including which parameters changed and which are unstable. See TraceRecomposition for usage details.</p> <p>The <code>ComposeStabilityAnalyzer</code> runtime is the API you use to configure logging behavior. You can enable or disable tracing, set custom loggers, and integrate with analytics platforms like Firebase. See Custom Logger for advanced configurations.</p> <p>The <code>stabilityDump</code> task generates a human-readable baseline file containing every composable's stability status. This baseline serves as your project's stability contract. The <code>stabilityCheck</code> task compares the current compilation output against that baseline and fails the build if stability has regressed. Together, these tasks enable Stability Validation in your CI/CD pipeline.</p> <p>Independence</p> <p>This Gradle plugin is completely independent of the IDE plugin. You can use it on its own for runtime tracing and CI validation, without installing the IDE plugin.</p>"},{"location":"gradle-plugin/stability-validation/","title":"Stability Validation","text":"<p>Stability Validation prevents stability regressions from reaching production. It's like git diff for composable stability: it tracks your composables' stability over time and automatically fails your build if stability regresses. Without it, a seemingly innocent change (like converting a <code>val</code> to <code>var</code> in a data class) can silently destabilize dozens of composables, and the performance regression slips through code review unnoticed.</p>"},{"location":"gradle-plugin/stability-validation/#how-it-works","title":"How It Works","text":"<p>Two Gradle tasks power stability validation. The <code>stabilityDump</code> task analyzes your compiled code and creates a snapshot (baseline) of every composable's stability status: function signatures, skippability, restartability, and the stability of each parameter. The <code>stabilityCheck</code> task compares the current compilation output against that snapshot and reports any differences.</p> Task Purpose <code>stabilityDump</code> Creates a snapshot of all composables' stability <code>stabilityCheck</code> Compares current stability against the snapshot <p>Think of <code>stabilityDump</code> as \"save the current state\" and <code>stabilityCheck</code> as \"has anything changed since the last save?\" Together, they create a feedback loop that catches stability regressions the moment they're introduced.</p> <p>Android variants</p> <p>For Android projects, variant-specific tasks are created, such as <code>debugStabilityDump</code> and <code>releaseStabilityCheck</code>. You can use those to only compile one variant, which speeds up the process in CI.</p>"},{"location":"gradle-plugin/stability-validation/#step-1-create-a-baseline","title":"Step 1: Create a Baseline","text":"<p>The first step is generating a baseline, a snapshot of your current composables' stability. This establishes the \"known good\" state that future changes are compared against. Run the compilation first (the stability analysis reads the compiled output), then generate the baseline.</p> <pre><code>./gradlew :app:compileDebugKotlin\n./gradlew :app:stabilityDump\n</code></pre> <p>This creates a human-readable <code>.stability</code> file at <code>app/stability/app.stability</code>. The file is intentionally designed to be readable in code reviews. When someone updates the baseline, reviewers can see exactly what changed and why.</p> <p>Example content:</p> <pre><code>@Composable\npublic fun com.example.UserCard(user: com.example.User): kotlin.Unit\n  skippable: true\n  restartable: true\n  params:\n    - user: STABLE (marked @Stable or @Immutable)\n\n@Composable\npublic fun com.example.UnstableCard(user: com.example.MutableUser): kotlin.Unit\n  skippable: false\n  restartable: true\n  params:\n    - user: UNSTABLE (has mutable properties)\n</code></pre> <p>Each composable entry shows the fully-qualified function signature, whether it's skippable and restartable, and the stability status of every parameter with a brief explanation of why it's stable or unstable.</p> <p>Commit this file to git so it becomes the shared baseline for your team:</p> <pre><code>git add app/stability/app.stability\ngit commit -m \"Add stability baseline for app module\"\n</code></pre>"},{"location":"gradle-plugin/stability-validation/#step-2-check-for-regressions","title":"Step 2: Check for Regressions","text":"<p>The <code>stabilityCheck</code> task compares your current code against the baseline. Run it after compilation to verify that no composable's stability has regressed.</p> <pre><code>./gradlew :app:compileDebugKotlin\n./gradlew :app:stabilityCheck\n</code></pre> <p>If nothing changed, the task passes silently:</p> <pre><code>\u2705 Stability check passed.\n</code></pre> <p>If stability regressed, the task fails with a clear message showing exactly what changed:</p> <pre><code>\u274c Stability check failed!\n\nThe following composables have changed stability:\n\n~ com.example.UserCard(user): stability changed from STABLE to UNSTABLE\n\nIf these changes are intentional, run './gradlew stabilityDump' to update the stability file.\n</code></pre> <p>The build fails, preventing the regression from being merged. The error message includes instructions for updating the baseline if the change is intentional. However, updating requires a deliberate <code>stabilityDump</code> and a separate commit, creating a documented decision in git history rather than an accidental regression.</p>"},{"location":"gradle-plugin/stability-validation/#change-types","title":"Change Types","text":"<p>The check detects three types of changes, each marked with a different symbol in the output.</p> <p>The <code>~</code> symbol indicates a stability regression, meaning a parameter or composable that was previously stable is now unstable. This is the most critical change type and the primary reason for running stability validation.</p> <p>The <code>+</code> symbol indicates a new composable was added. This appears when a new composable function exists in the current code but not in the baseline. This is informational and typically non-breaking.</p> <p>The <code>-</code> symbol indicates a composable was removed. This appears when a composable that existed in the baseline no longer exists in the current code.</p> Symbol Change Type Example <code>~</code> Stability regressed Parameter changed from STABLE to UNSTABLE <code>+</code> New composable added <code>+ com.example.NewScreen(title)</code> <code>-</code> Composable removed <code>- com.example.OldScreen(data)</code>"},{"location":"gradle-plugin/stability-validation/#configuration","title":"Configuration","text":"<p>You can customize what gets tracked, where baseline files are stored, and how the plugin responds to changes. All options are configured in the <code>composeStabilityAnalyzer</code> block in your <code>build.gradle.kts</code>.</p> <pre><code>composeStabilityAnalyzer {\n    stabilityValidation {\n        enabled.set(true)\n        outputDir.set(layout.projectDirectory.dir(\"stability\"))\n        includeTests.set(false)\n\n        // Ignore specific packages or classes\n        ignoredPackages.set(listOf(\"com.example.internal\"))\n        ignoredClasses.set(listOf(\"PreviewComposables\"))\n\n        // Exclude specific modules\n        ignoredProjects.set(listOf(\"benchmarks\", \"examples\"))\n\n        // Fail build on stability changes (default: true)\n        failOnStabilityChange.set(true)\n\n        // Only report regressive changes (default: false)\n        ignoreNonRegressiveChanges.set(false)\n\n        // Allow checks without a baseline file (default: false)\n        allowMissingBaseline.set(false)\n    }\n}\n</code></pre>"},{"location":"gradle-plugin/stability-validation/#failonstabilitychange","title":"<code>failOnStabilityChange</code>","text":"<p>By default, <code>stabilityCheck</code> fails the build when stability changes are detected. This is the right behavior for CI pipelines where you want to catch regressions before they're merged. However, during initial adoption or gradual migration, you may want to see stability issues without blocking builds.</p> <p>Setting <code>failOnStabilityChange</code> to <code>false</code> switches to warning-only mode. The task still reports all stability changes in the output, but the build succeeds regardless. This is useful when first adding stability validation to an existing project, allowing your team to see all current issues and fix them incrementally without blocking every PR.</p> <p>A common pattern is to use environment-based configuration: strict on CI, warning-only for local development.</p> <pre><code>composeStabilityAnalyzer {\n    stabilityValidation {\n        failOnStabilityChange.set(System.getenv(\"CI\") == \"true\")\n    }\n}\n</code></pre>"},{"location":"gradle-plugin/stability-validation/#ignorenonregressivechanges","title":"<code>ignoreNonRegressiveChanges</code>","text":"<p>When enabled, the check only flags stability regressions, specifically changes where a parameter or composable became less stable. Non-regressive changes (like a new stable composable being added, or an unstable parameter becoming stable) are not reported. This reduces noise in projects where composables are frequently added or removed, letting you focus exclusively on changes that could harm performance.</p> <pre><code>composeStabilityAnalyzer {\n    stabilityValidation {\n        ignoreNonRegressiveChanges.set(true)\n    }\n}\n</code></pre>"},{"location":"gradle-plugin/stability-validation/#excluding-composables","title":"Excluding Composables","text":"<p>Some composables shouldn't be included in stability validation: preview composables that only exist for Android Studio previews, debug-only screens, or experimental features still under active development. Use the <code>@IgnoreStabilityReport</code> annotation to exclude them.</p> <pre><code>@IgnoreStabilityReport\n@Preview\n@Composable\nfun UserCardPreview() {\n    UserCard(user = User(\"John\", 30))\n}\n</code></pre> <p>Composables annotated with <code>@IgnoreStabilityReport</code> are excluded from both the <code>.stability</code> baseline files generated by <code>stabilityDump</code> and the validation checks performed by <code>stabilityCheck</code>. This keeps your baseline clean and your CI checks focused on production code.</p>"},{"location":"gradle-plugin/stability-validation/#multi-module-projects","title":"Multi-Module Projects","text":"<p>For projects with multiple modules, each module gets its own <code>.stability</code> file. This keeps the baselines scoped to their module, making diffs smaller and easier to review.</p> <pre><code>project/\n\u251c\u2500\u2500 app/stability/app.stability\n\u251c\u2500\u2500 feature-auth/stability/feature-auth.stability\n\u2514\u2500\u2500 feature-profile/stability/feature-profile.stability\n</code></pre> <p>You can run <code>stabilityCheck</code> for all modules at once, which is the typical CI configuration:</p> <pre><code>./gradlew stabilityCheck\n</code></pre> <p>Or target specific modules when you only want to validate a subset of your project:</p> <pre><code>./gradlew :app:stabilityCheck\n./gradlew :feature-auth:stabilityCheck\n</code></pre> <p>Each module's baseline is independent, so updating the baseline for one module doesn't affect others. This is important in large projects where different teams own different modules, since a stability change in <code>feature-auth</code> doesn't require updating <code>feature-profile</code>'s baseline.</p>"},{"location":"gradle-plugin/trace-recomposition/","title":"TraceRecomposition","text":"<p><code>@TraceRecomposition</code> lets you trace the behavior of any composable function. By annotating a composable, you can log parameter changes whenever that function undergoes recomposition, without writing any logging code yourself. The compiler plugin instruments the function at compile time, injecting the necessary tracking code automatically.</p>"},{"location":"gradle-plugin/trace-recomposition/#basic-usage","title":"Basic Usage","text":"<p>Add the <code>@TraceRecomposition</code> annotation to any composable function you want to monitor. No other changes are needed; the compiler plugin handles the rest.</p> <pre><code>@TraceRecomposition\n@Composable\nfun UserProfile(user: User) {\n    Column {\n        Text(\"Name: ${user.name}\")\n        Text(\"Age: ${user.age}\")\n    }\n}\n</code></pre> <p>When this composable recomposes, detailed logs appear in Logcat showing the recomposition count, each parameter's stability status, and whether the parameter's value changed since the last composition.</p> <pre><code>D/Recomposition: [Recomposition #1] UserProfile\nD/Recomposition:   \u2514\u2500 user: User stable (User@abc123)\nD/Recomposition: [Recomposition #2] UserProfile\nD/Recomposition:   \u2514\u2500 user: User changed (User@abc123 \u2192 User@def456)\n</code></pre> <p>The first log entry shows the initial composition: the <code>user</code> parameter is stable and the log includes its identity hash. The second entry shows a recomposition triggered by the <code>user</code> parameter changing to a different instance, with both the old and new identity hashes displayed.</p>"},{"location":"gradle-plugin/trace-recomposition/#annotation-parameters","title":"Annotation Parameters","text":""},{"location":"gradle-plugin/trace-recomposition/#the-tag-parameter","title":"The <code>tag</code> Parameter","text":"<p>Tags let you categorize and filter your logs, which is especially useful in large projects where many composables might have tracing enabled simultaneously. By assigning meaningful tags, you can filter Logcat to show only the composables you're currently investigating.</p> <pre><code>@TraceRecomposition(tag = \"user-profile\")\n@Composable\nfun UserProfile(user: User) {\n    // Your composable code\n}\n</code></pre> <p>Logs now include the tag, making it easy to filter in Logcat:</p> <pre><code>D/Recomposition: [Recomposition #1] UserProfile (tag: user-profile)\nD/Recomposition:   \u2514\u2500 user: User stable (User@abc123)\n</code></pre> <p>Tags are also valuable when using a custom logger, since you can route events differently based on their tag, for example sending only critical flow recompositions (checkout, authentication) to your analytics platform while logging everything else to Logcat during development.</p>"},{"location":"gradle-plugin/trace-recomposition/#the-threshold-parameter","title":"The <code>threshold</code> Parameter","text":"<p>The <code>threshold</code> parameter controls when logging begins. By setting a threshold, the composable only produces log output after it has recomposed the specified number of times. This is essential for reducing noise, since many composables recompose once or twice during initial layout setup, which is completely normal and not a performance concern.</p> <pre><code>@TraceRecomposition(threshold = 3)\n@Composable\nfun FrequentlyRecomposingScreen() {\n    // Will only start logging after the 3rd recomposition\n}\n</code></pre> <p>Why thresholds matter</p> <p>Many composables recompose 1-2 times during initial setup. These are expected and not performance issues. By using <code>threshold = 3</code> or higher, you filter out the noise and focus on actual problems: composables that keep recomposing during user interaction, scrolling, or state updates.</p> <p>A threshold of <code>3</code> works well for most composables. For composables in scrolling lists or frequently updating screens where some recomposition is expected, a higher threshold (e.g., <code>10</code> or <code>20</code>) helps focus on truly excessive recomposition.</p>"},{"location":"gradle-plugin/trace-recomposition/#reading-the-logs","title":"Reading the Logs","text":"<p>Understanding the log output is key to diagnosing recomposition issues. Each log entry contains several pieces of information that, together, tell you exactly what happened and why.</p>"},{"location":"gradle-plugin/trace-recomposition/#first-recomposition","title":"First Recomposition","text":"<pre><code>D/Recomposition: [Recomposition #1] UserProfile\nD/Recomposition:   \u2514\u2500 user: User stable (User@abc123)\n</code></pre> <p>The <code>[Recomposition #1]</code> counter tells you this is the first time this composable instance is recomposing. <code>user: User</code> identifies the parameter by name and type. The <code>stable</code> label means the Compose compiler considers this parameter stable, so it won't cause unnecessary recompositions. The identity hash <code>(User@abc123)</code> lets you track whether the same instance is being passed across recompositions.</p> <p>This log confirms the composable is working correctly. A stable parameter on the first recomposition is expected behavior.</p>"},{"location":"gradle-plugin/trace-recomposition/#parameter-changed","title":"Parameter Changed","text":"<pre><code>D/Recomposition: [Recomposition #2] UserProfile\nD/Recomposition:   \u2514\u2500 user: User changed (User@abc123 \u2192 User@def456)\n</code></pre> <p>The <code>changed</code> label is the most important signal. It tells you this parameter's value is different from the last composition, which is the reason this composable recomposed. The arrow notation <code>(User@abc123 \u2192 User@def456)</code> shows the old and new identity hashes, confirming the value actually changed.</p> <p>This is normal behavior. The parameter changed, so the composable recomposed to reflect the new data. This is exactly what Compose should do.</p>"},{"location":"gradle-plugin/trace-recomposition/#unstable-parameter","title":"Unstable Parameter","text":"<pre><code>D/Recomposition: [Recomposition #1] UserCard (tag: user-card)\nD/Recomposition:   \u251c\u2500 user: MutableUser unstable (MutableUser@xyz789)\nD/Recomposition:   \u2514\u2500 Unstable parameters: [user]\n</code></pre> <p>The <code>unstable</code> label means the Compose compiler cannot guarantee this parameter won't change between recompositions. Because of this, Compose must always re-execute the composable; it can never be skipped. The <code>Unstable parameters: [user]</code> summary at the end lists all unstable parameters for quick reference.</p>"},{"location":"gradle-plugin/trace-recomposition/#multiple-parameters-mixed-stability","title":"Multiple Parameters (Mixed Stability)","text":"<pre><code>D/Recomposition: [Recomposition #5] ProductList (tag: products)\nD/Recomposition:   \u251c\u2500 title: String stable (Products)\nD/Recomposition:   \u251c\u2500 count: Int changed (4 \u2192 5)\nD/Recomposition:   \u251c\u2500 items: List&lt;Product&gt; unstable (List@abc)\nD/Recomposition:   \u2514\u2500 Unstable parameters: [items]\n</code></pre> <p>This log tells a complete story. The <code>title</code> parameter is stable and hasn't changed, so it's not contributing to this recomposition. The <code>count</code> parameter changed from <code>4</code> to <code>5</code>; this is why the composable recomposed. The <code>items</code> parameter is unstable, meaning it will trigger recomposition regardless of whether its value actually changed. Even though <code>count</code> changing is the immediate cause here, the unstable <code>items</code> parameter is a latent performance issue that should be addressed.</p>"},{"location":"gradle-plugin/trace-recomposition/#enable-logging","title":"Enable Logging","text":"<p>The <code>@TraceRecomposition</code> annotation instruments your code at compile time, but the runtime logging system must be explicitly enabled. Add this to your <code>Application</code> class to activate logging:</p> <pre><code>class MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        ComposeStabilityAnalyzer.setEnabled(BuildConfig.DEBUG)\n    }\n}\n</code></pre> <p>Production builds</p> <p>Always wrap with <code>BuildConfig.DEBUG</code> to avoid performance overhead in production. The instrumented code is still present in release builds, but when logging is disabled, the overhead is minimal (just a boolean check on each recomposition). If you don't call <code>ComposeStabilityAnalyzer.setEnabled()</code>, no logs will appear even with <code>@TraceRecomposition</code>.</p>"},{"location":"gradle-plugin/trace-recomposition/#real-world-debugging-example","title":"Real-World Debugging Example","text":"<p>Consider a common scenario: your product list screen feels laggy during scrolling. You suspect excessive recompositions but aren't sure which composable is the culprit or what's causing it.</p> <p>Add tracking to the composable you suspect. Use a meaningful tag and a threshold to filter out initial setup recompositions.</p> <pre><code>@TraceRecomposition(tag = \"product-card\", threshold = 3)\n@Composable\nfun ProductCard(product: Product, onClick: () -&gt; Unit) {\n    Card(onClick = onClick) {\n        Text(product.name)\n        Text(\"$${product.price}\")\n    }\n}\n</code></pre> <p>Run the app and check Logcat. Filter by <code>product-card</code> to see only this composable's events. After scrolling through the list, you see logs appearing rapidly:</p> <pre><code>D/Recomposition: [Recomposition #3] ProductCard (tag: product-card)\nD/Recomposition:   \u251c\u2500 product: Product unstable (Product@abc)\nD/Recomposition:   \u251c\u2500 onClick: () -&gt; Unit stable (Function@xyz)\nD/Recomposition:   \u2514\u2500 Unstable parameters: [product]\n</code></pre> <p>The logs reveal the problem clearly. The <code>onClick</code> lambda is stable (no issue there), but the <code>product</code> parameter is unstable. Every time the parent recomposes, even if the product data hasn't changed, this <code>ProductCard</code> must re-execute because Compose can't verify that <code>product</code> is the same value.</p> <p>Fix the root cause. Check the <code>Product</code> class and you'll likely find mutable properties:</p> <pre><code>// Before (UNSTABLE)\ndata class Product(var name: String, var price: Double)\n\n// After (STABLE)\ndata class Product(val name: String, val price: Double)\n</code></pre> <p>Verify the fix by running the app again. The logs now show stable parameters:</p> <pre><code>D/Recomposition: [Recomposition #3] ProductCard (tag: product-card)\nD/Recomposition:   \u251c\u2500 product: Product stable (Product@abc)\nD/Recomposition:   \u2514\u2500 onClick: () -&gt; Unit stable (Function@xyz)\n</code></pre> <p>The <code>ProductCard</code> is now skippable. During scrolling, Compose will skip recomposing cards whose <code>product</code> and <code>onClick</code> values haven't changed, resulting in noticeably smoother performance.</p>"},{"location":"gradle-plugin/trace-recomposition/#best-practices","title":"Best Practices","text":"<p>Be selective about which composables you track. Adding <code>@TraceRecomposition</code> to every composable creates log noise that makes it harder to find real issues. Focus on composables you suspect have performance problems: list items, complex screens with many parameters, and composables at the boundary between state management and UI.</p> <p>Use meaningful tags that reflect your app's feature structure. Tags like <code>\"auth-flow\"</code>, <code>\"checkout-item\"</code>, and <code>\"feed-card\"</code> are immediately understandable when scanning logs, while generic tags like <code>\"card1\"</code> or <code>\"screen\"</code> provide no useful context.</p> <p>Set appropriate thresholds based on the composable's expected behavior. A threshold of <code>3</code> works for most cases, filtering out initial layout. For composables in scrolling lists or animated screens where frequent recomposition is normal, use <code>10</code> or higher so you only see truly excessive recomposition events.</p>"},{"location":"ide-plugin/configuration/","title":"Configuration","text":"<p>You can customize the Compose Stability Analyzer plugin to match your preferences, IDE theme, and project requirements. All settings are accessible via Settings &gt; Tools &gt; Compose Stability Analyzer.</p> <p> </p>"},{"location":"ide-plugin/configuration/#general-settings","title":"General Settings","text":"<p>The general settings control which visual features are active and how the plugin analyzes your code.</p> <p>Enable stability checks is the master toggle for the entire plugin. When disabled, no gutter icons, tooltips, inline hints, or inspections will appear. This is useful if you want to temporarily disable the plugin without uninstalling it (for example, when working on a non-Compose part of your project where the analysis overhead isn't needed).</p> <p>Strong Skipping mode controls whether the analyzer accounts for Compose's Strong Skipping mode when determining stability. With Strong Skipping enabled (the default since Compose Compiler 1.5.4+), more composables are considered skippable because unstable parameters are compared by instance equality. If your project doesn't use Strong Skipping, disable this setting so the analysis reflects your actual compiler behavior.</p> <p>Show gutter icons, Show inline hints, and Show warnings let you independently toggle each visual indicator. For example, you might want gutter icons for a quick overview but find inline hints too noisy. You can disable hints while keeping the gutter icons active. Each indicator serves a different purpose, and the right combination depends on your workflow.</p> <p>Show in test source sets controls whether the plugin analyzes composables in test directories. By default, this is disabled because test composables (previews, test fixtures) typically don't need stability optimization. Enable this if you want to analyze composable stability in your test code as well.</p> Setting Default Description Enable stability checks <code>true</code> Toggle the entire plugin on/off Strong Skipping mode <code>true</code> Analyze with Strong Skipping mode enabled Show gutter icons <code>true</code> Show colored dots in the editor margin Show inline hints <code>true</code> Show stability badges next to parameters Show warnings <code>true</code> Show warning underlines for unstable composables Show in test source sets <code>false</code> Enable gutter icons in test directories"},{"location":"ide-plugin/configuration/#parameter-hint-colors","title":"Parameter Hint Colors","text":"<p>The default colors for stability indicators (green for stable, red for unstable, yellow for runtime) work well with most IDE themes, but you can customize them to improve contrast or match your personal color scheme. Navigate to the Parameter Hint Colors section in the plugin settings to adjust the colors for each stability level independently.</p> <p>This is especially useful if you use a high-contrast theme, a colorblind-friendly theme, or simply prefer different colors. The gutter icons, inline hints, and Stability Explorer all respect these color settings.</p>"},{"location":"ide-plugin/configuration/#stability-configuration-file","title":"Stability Configuration File","text":"<p>The Compose compiler determines stability based on type annotations and property mutability. However, there are cases where a type is effectively stable but the compiler can't infer it: third-party library types without <code>@Stable</code> annotations, code-generated types, or legacy classes you know are immutable but can't easily modify. The stability configuration file lets you tell the analyzer to treat these types as stable.</p>"},{"location":"ide-plugin/configuration/#global-settings","title":"Global Settings","text":"<p>Global settings apply to all projects on your machine. Create your configuration file anywhere on your system, then go to Settings &gt; Tools &gt; Compose Stability Analyzer and either add patterns directly to the Ignored Type Patterns section or reference a file path in the Stability configuration file field.</p> <p>Global settings are ideal for types you frequently encounter across projects, such as common third-party library types (<code>java.time.LocalDateTime</code>, <code>kotlinx.datetime.Instant</code>, etc.).</p>"},{"location":"ide-plugin/configuration/#per-project-settings-recommended","title":"Per-Project Settings (Recommended)","text":"<p>Per-project settings are stored alongside your project and can be shared with your team through version control. Create a configuration file in your project (e.g., <code>config/stability-config.txt</code>), then go to Settings &gt; Tools &gt; Compose Stability Analyzer &gt; Project Configuration and set the path to your file. Commit the configuration file to version control so every team member uses the same stability rules.</p> <p>Precedence</p> <p>Per-project settings take precedence over global settings. This means you can have global settings for your personal preferences and project-specific settings that your entire team uses. When both exist, the project-level configuration wins.</p>"},{"location":"ide-plugin/configuration/#configuration-file-format","title":"Configuration File Format","text":"<p>The configuration file is a plain text file where each line specifies a fully-qualified type name or a wildcard pattern. Lines starting with <code>//</code> are comments.</p> <pre><code>// Consider LocalDateTime stable (it's immutable but lacks @Stable annotation)\njava.time.LocalDateTime\n\n// Consider all types in the datalayer package stable\ncom.datalayer.*\n\n// Consider all types in datalayer and all sub-packages stable\ncom.datalayer.**\n</code></pre> <p>The single wildcard (<code>*</code>) matches types within a specific package only. The double wildcard (<code>**</code>) matches types within a package and all of its sub-packages recursively. This distinction is important for large packages where you want fine-grained control.</p>"},{"location":"ide-plugin/configuration/#ignored-type-patterns","title":"Ignored Type Patterns","text":"<p>The Ignored Type Patterns field in the settings provides a quick way to exclude specific types from stability analysis without creating a separate configuration file. Types matching these patterns are treated as stable by the analyzer.</p> <pre><code>com.example.internal.*\ncom.thirdparty.model.**\n</code></pre> <p>This is convenient for quick overrides, but for team-shared configuration, the per-project stability configuration file is the recommended approach since it can be committed to version control and reviewed in pull requests.</p>"},{"location":"ide-plugin/getting-started/","title":"Getting Started","text":"<p>The Compose Stability Analyzer IntelliJ Plugin brings visual stability analysis directly into your IDE, helping you identify and fix performance issues while you code. Instead of waiting for runtime or build-time reports, you get instant feedback right in Android Studio or IntelliJ IDEA.</p>"},{"location":"ide-plugin/getting-started/#installation","title":"Installation","text":"<p>You can install the plugin from the JetBrains Marketplace. Open Android Studio (or IntelliJ IDEA), navigate to Settings &gt; Plugins &gt; Marketplace, and search for Compose Stability Analyzer. Click Install and restart your IDE when prompted.</p> <p></p> <p>After installation, open any Kotlin file containing <code>@Composable</code> functions. If you see colored dots appearing in the left margin of your editor next to composable function declarations, the plugin is working correctly.</p>"},{"location":"ide-plugin/getting-started/#requirements","title":"Requirements","text":"<p>The plugin requires Android Studio or IntelliJ IDEA 2024.2+ (build 242 or later) with Kotlin 2.0.21+ configured in a Jetpack Compose project. It works with both single-module and multi-module project structures.</p>"},{"location":"ide-plugin/getting-started/#what-youll-see","title":"What You'll See","text":"<p>Once installed, the plugin provides six types of visual feedback that work together to give you a complete picture of your composables' stability.</p> <p>Gutter Icons are colored dots that appear in the left margin of your editor. Green means the composable is skippable (all parameters stable), yellow means stability is determined at runtime, and red means the composable has unstable parameters and cannot be skipped. This is the quickest way to scan your code for potential performance issues.</p> <p>Hover Tooltips appear when you move your mouse over a composable function name. They show a detailed stability breakdown including whether the composable is skippable and restartable, how many parameters are stable vs. unstable, and the specific reason behind each parameter's stability status.</p> <p>Inline Hints are small badges that appear directly next to each parameter's type declaration. They let you see the stability of every parameter at a glance without needing to hover, which is particularly useful for composables with many parameters.</p> <p>Code Inspections go beyond passive indicators. When a composable has unstable parameters, the plugin highlights the issue with a warning underline and offers quick fixes through the Alt+Enter menu, such as adding <code>@TraceRecomposition</code> for runtime debugging.</p> <p>Recomposition Cascade lets you trace the downstream impact of recomposition. Right-click any composable and select \"Analyze Recomposition Cascade\" to see a tree of all child composables that would be affected, with stability status for each one.</p> <p>Live Recomposition Heatmap bridges runtime behavior with your IDE by displaying actual recomposition counts from a connected device directly above composable functions in the editor. Color-coded annotations (green, yellow, red) highlight the hottest spots in your UI in real time.</p>"},{"location":"ide-plugin/getting-started/#verification","title":"Verification","text":"<p>To verify the plugin is working, open any Kotlin file with <code>@Composable</code> functions and look for colored dots in the left margin (the gutter area). Hover over a composable function name; you should see a tooltip with detailed stability information. If nothing appears, the plugin may be disabled.</p> <p>Troubleshooting</p> <p>If the plugin doesn't appear to work, check Settings &gt; Tools &gt; Compose Stability Analyzer and make sure Enable stability checks is turned on. Also verify that your project uses Kotlin 2.0.21+ and has Jetpack Compose configured.</p>"},{"location":"ide-plugin/gutter-icons/","title":"Gutter Icons &amp; Tooltips","text":"<p>Gutter icons and hover tooltips are the primary visual feedback mechanisms of the Compose Stability Analyzer plugin. Together, they let you quickly scan your code for stability issues and then drill into the details of any composable that needs attention.</p>"},{"location":"ide-plugin/gutter-icons/#gutter-icons","title":"Gutter Icons","text":"<p>Gutter icons appear in the left margin of your editor next to every <code>@Composable</code> function declaration. They provide an instant, at-a-glance summary of each composable's stability status. You can scan an entire file in seconds just by looking at the colors in the margin.</p> <p></p>"},{"location":"ide-plugin/gutter-icons/#icon-colors","title":"Icon Colors","text":"<p>The icon color tells you whether a composable can be skipped during recomposition.</p> <p>A green dot means the composable is skippable: all of its parameters are stable, so Compose can safely skip re-executing the function when its parent recomposes, as long as the parameter values haven't changed. This is the ideal state for performance.</p> <p>A yellow dot means the composable's stability is determined at runtime. This typically happens with generic types or types whose stability depends on their type arguments. The composable may or may not be skipped depending on the actual values passed at runtime.</p> <p>A red dot means the composable is not skippable. It has one or more unstable parameters, which means Compose must always re-execute it during recomposition, even if the parameter values haven't actually changed. These composables are worth investigating if you're experiencing performance issues.</p> Color Meaning Green Skippable: all parameters are stable Yellow Runtime: stability determined at runtime Red Not skippable: has unstable parameters"},{"location":"ide-plugin/gutter-icons/#hover-tooltips","title":"Hover Tooltips","text":"<p>When you hover your mouse over a composable function name, a detailed tooltip appears with a complete stability breakdown. This is where you get the why behind the gutter icon color. You don't just see that a composable is unstable; you see exactly which parameters are the problem and the specific reason each one is stable or unstable.</p> <p>The tooltip shows whether the composable is skippable (can be skipped during recomposition) and restartable (can independently restart when state changes). It lists the total number of stable vs. unstable parameters, then breaks down each parameter individually, showing the parameter name, type, stability status, and the reason for that status (e.g., \"has mutable properties\", \"marked @Stable\", \"primitive type\").</p> <p>If the composable has receivers (such as extension functions on a scope), those are also included in the tooltip with their stability information.</p>"},{"location":"ide-plugin/gutter-icons/#practical-workflow","title":"Practical Workflow","text":"<p>The most effective way to use gutter icons and tooltips is as a two-step process. First, scan your code by scrolling through and looking at the gutter icons. Red and yellow dots stand out visually, drawing your attention to composables that may need investigation. You don't need to read any code at this stage; the colors tell you everything.</p> <p>When you spot a red or yellow dot, hover over the composable function name to see the detailed tooltip. The tooltip tells you exactly which parameters are unstable and why, giving you the information you need to decide whether to fix the instability (by making properties <code>val</code>, adding <code>@Stable</code>/<code>@Immutable</code>, or using immutable collections) or to accept it as intentional.</p> <p>After making changes, the gutter icon updates in real time. When a red dot turns green, you know the composable is now fully stable and skippable. Compose will be able to skip it during recomposition whenever its parameters haven't changed.</p>"},{"location":"ide-plugin/inline-hints/","title":"Inline Parameter Hints","text":"<p>Inline hints are small badges that appear right next to parameter types in your composable function declarations, showing the stability of each individual parameter. While gutter icons give you a function-level summary and tooltips provide detailed breakdowns on hover, inline hints let you see parameter-level stability information directly in your code, without any interaction required.</p>"},{"location":"ide-plugin/inline-hints/#how-it-works","title":"How It Works","text":"<p>Each parameter in your composable function gets a small inline badge indicating whether it is STABLE, UNSTABLE, or RUNTIME. The badges appear immediately after the parameter's type annotation, making them visible as you read through function signatures.</p> <p></p> <p>This level of detail is particularly valuable when working with composables that have many parameters. Instead of hovering over the function name and scanning a tooltip for a specific parameter, you can see the stability status of every parameter at once while reading the code naturally. If a composable has five parameters and only one is unstable, the inline hint tells you exactly which one without any extra interaction.</p>"},{"location":"ide-plugin/inline-hints/#hint-colors","title":"Hint Colors","text":"<p>The hint colors match the gutter icon colors to maintain a consistent visual language across the plugin. You can customize these colors in the plugin settings to match your IDE theme or personal preferences.</p> Stability Default Color Meaning STABLE Green This parameter won't cause unnecessary recompositions. It is either a primitive type, annotated with <code>@Stable</code>/<code>@Immutable</code>, or a data class with only <code>val</code> properties of stable types. UNSTABLE Red This parameter may trigger unnecessary recompositions. It likely has mutable properties (<code>var</code>), uses mutable collections, or comes from a module not compiled with the Compose compiler. RUNTIME Yellow This parameter's stability is determined at runtime, typically because it involves generics or interface types whose concrete implementation may or may not be stable."},{"location":"ide-plugin/inline-hints/#customizing-colors","title":"Customizing Colors","text":"<p>To change the hint colors, go to Settings &gt; Tools &gt; Compose Stability Analyzer and find the Parameter Hint Colors section. You can adjust the colors for each stability level independently. This is especially useful if you're using a custom IDE theme where the default green/red/yellow colors don't provide enough contrast or don't match your color scheme.</p>"},{"location":"ide-plugin/inline-hints/#when-this-is-useful","title":"When This Is Useful","text":"<p>Inline hints shine in several scenarios. When you're reviewing code (whether your own or a teammate's), they give you an immediate sense of which parameters might cause performance issues without requiring you to interact with the editor. When you're refactoring a composable's parameters, the hints update in real time, confirming whether your changes improved or worsened stability. And when you're learning how Compose stability works, seeing the stability status directly next to each type helps build intuition about which types Compose considers stable and why.</p> <p>If you find the inline hints too noisy for everyday coding, you can disable them independently from gutter icons in the plugin settings while still keeping the other visual indicators active.</p>"},{"location":"ide-plugin/inspections/","title":"Code Inspections","text":"<p>Code inspections go beyond passive visual indicators. They actively analyze your composable functions and suggest concrete improvements. While gutter icons and inline hints show you the current state, inspections draw your attention to problems and help you fix them, making them the most actionable feature of the plugin.</p>"},{"location":"ide-plugin/inspections/#how-inspections-work","title":"How Inspections Work","text":"<p>When the plugin detects an unstable composable, it highlights the function with a warning underline in the editor. This is the same kind of underline you see for other IDE warnings (like unused variables or deprecated API calls), so it fits naturally into your existing code review workflow.</p> <p>Placing your cursor on the highlighted function and pressing Alt+Enter (or Option+Enter on macOS) opens the quick fix menu. The plugin offers context-aware actions based on the specific stability issue, from adding runtime tracing to suppressing the warning if the instability is intentional.</p> <p>This approach mirrors having an automated code reviewer focused specifically on Compose performance. Rather than requiring you to remember to check stability manually, the plugin surfaces issues as you write code and provides one-click fixes.</p>"},{"location":"ide-plugin/inspections/#available-quick-fixes","title":"Available Quick Fixes","text":""},{"location":"ide-plugin/inspections/#add-tracerecomposition","title":"Add @TraceRecomposition","text":"<p>When a composable has unstable parameters, the most common first step is understanding how the instability affects runtime behavior. The plugin offers to add the <code>@TraceRecomposition</code> annotation, which enables detailed runtime logging showing exactly when and why the composable recomposes.</p> <pre><code>// Before: unstable composable with no visibility into recomposition behavior\n@Composable\nfun UserCard(user: MutableUser) {\n    Text(user.name)\n}\n\n// After: with trace annotation added via quick fix\n@TraceRecomposition(tag = \"user-card\")\n@Composable\nfun UserCard(user: MutableUser) {\n    Text(user.name)\n}\n</code></pre> <p>Once the annotation is added, running the app produces Logcat output showing each recomposition event, including which parameters changed, which are stable, and which are unstable. This runtime data helps you decide whether the instability is actually causing performance issues or is benign in practice. See the TraceRecomposition documentation for details on reading the logs.</p>"},{"location":"ide-plugin/inspections/#suppress-warning","title":"Suppress Warning","text":"<p>Not every unstable composable needs to be fixed. Some composables have parameters that are technically unstable (e.g., a <code>List&lt;Item&gt;</code>) but rarely change in practice, or the composable is simple enough that re-executing it has negligible cost. In these cases, the quick fix menu offers a suppression option that disables the warning for that specific composable without affecting the rest of your project.</p> <p>Suppressing a warning is a deliberate decision. It tells the plugin (and anyone reading your code) that you've considered the instability and decided it's acceptable. This is preferable to disabling inspections globally, which would hide genuine issues.</p>"},{"location":"ide-plugin/inspections/#inspection-severity","title":"Inspection Severity","text":"<p>You can configure how prominently the plugin highlights stability issues. Navigate to Settings &gt; Editor &gt; Inspections and search for Compose Stability. The severity level controls how the issue is presented in the editor:</p> <p>Error displays a red underline and treats the issue as a compilation-level problem. This is the strictest setting and is useful if your team has decided that all composables should be stable.</p> <p>Warning (the default) displays a yellow underline. This is appropriate for most projects, as it draws attention to instability without being as visually aggressive as an error.</p> <p>Weak Warning displays a subtle underline that's less prominent than a full warning. This works well during initial adoption, when you want to see stability issues without them dominating your editor.</p> <p>Information shows the issue only in the inspection results panel and doesn't underline the code at all. Use this if you want to track stability issues without any visual noise in the editor.</p>"},{"location":"ide-plugin/recomposition-cascade/","title":"Recomposition Cascade","text":"<p>The Recomposition Cascade Visualizer lets you trace the downstream impact of a composable's recomposition. Starting from any <code>@Composable</code> function, it analyzes the call tree to show which child composables would be affected when the parent recomposes, along with each one's stability status. This helps you understand the ripple effect of a single unstable composable across your UI hierarchy.</p> <p></p>"},{"location":"ide-plugin/recomposition-cascade/#how-to-use","title":"How to Use","text":"<p>Right-click any <code>@Composable</code> function in the editor and select Analyze Recomposition Cascade from the context menu. The plugin performs a background analysis of the function's call tree and displays the results in the Cascade tab of the Compose Stability Analyzer tool window.</p> <p>The analysis runs in the background with cancellation support, so you can continue working in the editor while it processes. For large call trees, a progress indicator shows the current analysis status.</p>"},{"location":"ide-plugin/recomposition-cascade/#tree-view","title":"Tree View","text":"<p>The results appear as a hierarchical tree rooted at the composable you selected. Each node represents a downstream composable that the root calls, directly or transitively. Nodes are nested to reflect the actual call structure: if <code>ScreenA</code> calls <code>Header</code> which calls <code>Title</code>, the tree shows <code>ScreenA</code> &gt; <code>Header</code> &gt; <code>Title</code>.</p> <p>Each node displays the composable's name and its stability status. Skippable composables appear with a green indicator, meaning all their parameters are stable and Compose can skip them during recomposition. Non-skippable composables appear with a red indicator, meaning they have at least one unstable parameter and will always re-execute when their parent recomposes.</p>"},{"location":"ide-plugin/recomposition-cascade/#summary-statistics","title":"Summary Statistics","text":"<p>At the top of the cascade tree, a summary node shows aggregate statistics for the entire call tree: the total number of downstream composables found, how many are skippable, how many are non-skippable, and the maximum depth of the tree. This gives you a quick sense of the blast radius. A root composable with 15 downstream composables and 8 of them non-skippable has a much larger performance impact than one with 3 downstream composables that are all skippable.</p>"},{"location":"ide-plugin/recomposition-cascade/#cycle-detection","title":"Cycle Detection","text":"<p>Compose UIs can have recursive or mutually recursive composable calls (for example, a tree-rendering composable that calls itself for child nodes). The cascade analyzer detects these cycles and marks them in the tree rather than entering an infinite loop. When a cycle is detected, the node shows a cycle indicator and stops expanding further along that path.</p> <p>The analysis also enforces a configurable maximum depth limit (default: 10 levels) to keep results manageable and prevent excessively deep trees from slowing down the analysis.</p>"},{"location":"ide-plugin/recomposition-cascade/#navigation","title":"Navigation","text":"<p>Double-clicking any node in the cascade tree navigates directly to that composable's source code in the editor. This makes the cascade view an effective tool for tracing performance issues through your UI hierarchy: spot a non-skippable composable deep in the tree, double-click to jump to its source, and investigate why its parameters are unstable.</p>"},{"location":"ide-plugin/recomposition-cascade/#practical-workflow","title":"Practical Workflow","text":"<p>The cascade visualizer is most useful when you've identified a composable with performance issues and want to understand the full impact. For example, if your main screen composable recomposes frequently, running a cascade analysis shows you every downstream composable that gets affected. You might discover that a single unstable data class parameter at the root causes dozens of child composables to re-execute unnecessarily.</p> <p>Start by analyzing high-level screen composables to get a broad view of your recomposition impact. Focus on branches where non-skippable composables cluster together, as these represent the highest-impact areas for optimization. After fixing stability issues, re-run the cascade analysis to confirm that the downstream composables are now skippable.</p>"},{"location":"ide-plugin/recomposition-heatmap/","title":"Live Recomposition Heatmap","text":"<p>The Live Recomposition Heatmap bridges runtime behavior with your IDE by displaying actual recomposition counts from a connected device directly above composable functions in the editor. While static analysis tells you which composables could recompose unnecessarily, the heatmap shows you which ones actually are recomposing in real time, with color-coded severity indicators that highlight the hottest spots in your UI.</p> <p></p>"},{"location":"ide-plugin/recomposition-heatmap/#prerequisites","title":"Prerequisites","text":"<p>The heatmap reads <code>@TraceRecomposition</code> events from your running app via ADB. To use it, you need:</p> <ol> <li>The Compose Stability Analyzer Gradle plugin applied to your project.</li> <li>Composable functions annotated with <code>@TraceRecomposition</code>.</li> <li>Logging enabled via <code>ComposeStabilityAnalyzer.setEnabled(true)</code> in your <code>Application</code> class.</li> <li>A device or emulator connected via ADB.</li> </ol> <p>ADB Path</p> <p>The plugin looks for ADB in your <code>ANDROID_HOME</code> or <code>ANDROID_SDK_ROOT</code> environment variable under <code>platform-tools/adb</code>. If neither is set, it falls back to <code>adb</code> on your system PATH. If ADB is not found, the plugin shows a notification with instructions.</p>"},{"location":"ide-plugin/recomposition-heatmap/#starting-and-stopping","title":"Starting and Stopping","text":"<p>Open the Compose Stability Analyzer tool window (View &gt; Tool Windows &gt; Compose Stability Analyzer) and click the Start/Stop Recomposition Heatmap button in the tool window title bar. This button is visible regardless of which tab (Explorer, Cascade, or Heatmap) is currently selected.</p> <p>When you click start, the plugin checks for connected ADB devices. If exactly one device is connected, monitoring begins immediately. If multiple devices are found, a picker popup appears so you can select which device to monitor. If no devices are connected, a notification prompts you to connect one.</p> <p>You can also access the toggle via the Code menu in the main menu bar.</p> <p>While running, the plugin reads logcat output in real time, filtering for recomposition events emitted by the <code>@TraceRecomposition</code> annotation. To stop monitoring, click the same button again.</p>"},{"location":"ide-plugin/recomposition-heatmap/#reading-the-heatmap","title":"Reading the Heatmap","text":"<p>When the heatmap is active and your app is running with <code>@TraceRecomposition</code> composables, recomposition counts appear as inline annotations directly above each composable function in the editor. Each annotation shows the total number of recompositions observed for that composable since monitoring started.</p> <p>The annotations are color-coded by severity to help you quickly identify hot spots:</p> Color Recomposition Count Meaning Green Fewer than 10 Normal recomposition frequency Yellow 10 to 50 Moderate; worth investigating Red More than 50 Excessive; likely a performance issue <p>These thresholds are configurable in Settings &gt; Tools &gt; Compose Stability Analyzer under the Recomposition Heatmap section.</p> <p>Name matching</p> <p>The heatmap matches recomposition events to composable functions by simple name (e.g., <code>UserProfile</code>). If multiple composable functions share the same name across different files, they will share the same recomposition data. The annotation tooltip notes this when applicable.</p>"},{"location":"ide-plugin/recomposition-heatmap/#inspecting-recomposition-details","title":"Inspecting Recomposition Details","text":"<p>Clicking on a heatmap annotation in the editor opens the Heatmap tab in the Compose Stability Analyzer tool window, pre-populated with detailed recomposition data for that composable. The detail view shows:</p> <ul> <li>Total recomposition count and the maximum count from a single event.</li> <li>Recent recomposition events listed chronologically, each showing the recomposition number and timestamp.</li> <li>Parameter changes for each event, including which parameters changed, which were stable, and which were unstable.</li> </ul> <p>This lets you go from a high-level \"this composable recomposed 47 times\" observation directly to the specific parameter changes that triggered each recomposition, without switching to Logcat or searching through logs manually.</p>"},{"location":"ide-plugin/recomposition-heatmap/#configuration","title":"Configuration","text":"<p>The heatmap settings are available in Settings &gt; Tools &gt; Compose Stability Analyzer under the Recomposition Heatmap section.</p> Setting Default Description Enable heatmap <code>true</code> Master toggle for the heatmap feature Auto-start <code>false</code> Automatically start monitoring when a single device is connected Show when stopped <code>true</code> Keep displaying the last heatmap data after stopping monitoring Green threshold <code>10</code> Recomposition count below which the annotation is green Red threshold <code>50</code> Recomposition count above which the annotation is red"},{"location":"ide-plugin/recomposition-heatmap/#practical-workflow","title":"Practical Workflow","text":"<p>The heatmap is most effective as a complement to static analysis. Use gutter icons and the Stability Explorer to identify composables that could have performance issues, then use the heatmap to confirm which ones actually do during real user interactions.</p> <p>A typical workflow looks like this: annotate your screen-level composables with <code>@TraceRecomposition</code>, start the heatmap, and then interact with your app normally (scrolling, navigating, entering data). Watch the editor for red annotations appearing. When you spot a hot composable, click its annotation to see the parameter change history and identify whether the recompositions are caused by actual data changes or by unstable parameters triggering unnecessary work.</p> <p>After fixing stability issues, clear the heatmap data using the clear button in the Heatmap tab toolbar and repeat your interactions. The recomposition counts should drop, confirming that your optimizations are working at runtime, not just in static analysis.</p>"},{"location":"ide-plugin/stability-explorer/","title":"Stability Explorer","text":"<p>The Stability Explorer provides a dedicated tool window in your IDE, allowing you to visually trace which composable functions are skippable or non-skippable across your entire project. While gutter icons and inline hints work at the file level, the Stability Explorer gives you a project-wide overview, making it easy to identify modules, packages, or files that have the most stability issues.</p> <p></p>"},{"location":"ide-plugin/stability-explorer/#how-to-open","title":"How to Open","text":"<p>The Stability Explorer requires the Compose Stability Analyzer Gradle plugin to be installed, because it reads stability information from JSON files generated during compilation. Without the Gradle plugin, the explorer will show an empty state with setup instructions.</p> <p>To open the explorer, go to View &gt; Tool Windows &gt; Compose Stability Analyzer. You'll see an icon appear on the right side of Android Studio. Click it to open the panel. After a clean build of your project, click the Refresh button on the panel to populate the tree with your composables' stability data.</p>"},{"location":"ide-plugin/stability-explorer/#tree-view","title":"Tree View","text":"<p>The explorer organizes all composables in a hierarchical tree view grouped by Module &gt; Package &gt; File &gt; Composable. This structure mirrors your project's organization, making it easy to navigate to the area you're interested in.</p> <p>Each node in the tree displays a stability summary in the format (XS, YNS), where S is the count of skippable composables and NS is the count of non-skippable composables within that scope. Zero counts are hidden to keep the UI clean. For example, a package showing (3S, 1NS) tells you that three composables are skippable and one is not. You can expand the package node to find which one needs attention.</p>"},{"location":"ide-plugin/stability-explorer/#color-coding","title":"Color Coding","text":"<p>The tree uses a simple two-color system. Green nodes represent skippable composables where all parameters are stable. Yellow nodes represent non-skippable composables that have at least one unstable parameter. Parent nodes (modules, packages, files) inherit the color of their most critical child; if any composable within a package is non-skippable, the package node appears yellow.</p> <p>This color propagation means you can quickly scan the top-level module nodes to find which modules have stability issues, then drill down into the specific packages and files without expanding every node.</p>"},{"location":"ide-plugin/stability-explorer/#filtering","title":"Filtering","text":"<p>The filter buttons at the top of the panel let you focus on the composables that matter most. The All filter shows every composable in the project, giving you a complete overview. The Skippable filter shows only composables with all stable parameters, which is useful for confirming that your optimized composables are still stable. The Non-skippable filter shows only composables with unstable parameters, which is the most useful filter when you're actively working on improving performance.</p>"},{"location":"ide-plugin/stability-explorer/#navigation","title":"Navigation","text":"<p>Double-clicking any composable in the tree navigates directly to its source code location in the editor. This makes the Stability Explorer an effective starting point for a performance improvement session: filter to non-skippable composables, scan the list, and double-click to jump straight to the code that needs attention.</p>"},{"location":"ide-plugin/stability-explorer/#details-pane","title":"Details Pane","text":"<p>Selecting a composable in the tree populates the details pane at the bottom of the explorer. The details pane shows the complete function signature, whether the composable is skippable and restartable, the full parameter list with individual stability statuses, and the specific reason each parameter is stable or unstable. This is the same information available in the hover tooltip, but presented in a persistent panel that doesn't disappear when you move your mouse.</p> <p>The details pane is particularly useful when comparing multiple composables. You can click through different composables in the tree while keeping the details visible, making it easy to spot patterns (e.g., multiple composables that are unstable because they all share the same unstable data class).</p>"}]}