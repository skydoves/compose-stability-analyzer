/*
 * Designed and developed by 2025 skydoves (Jaewoong Eum)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.skydoves.compose.stability.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction

/**
 * Task to dump composable stability information to a file.
 *
 * Similar to apiDump from binary-compatibility-validator.
 */
public abstract class StabilityDumpTask : DefaultTask() {

  /**
   * Input file containing stability information generated by the compiler.
   * Using InputFiles instead of InputFile to allow the file to not exist yet.
   */
  @get:InputFiles
  public abstract val stabilityInputFiles: ConfigurableFileCollection

  /**
   * Output directory where the stability file will be written.
   */
  @get:OutputDirectory
  public abstract val outputDir: DirectoryProperty

  /**
   * Packages to ignore.
   */
  @get:Input
  public abstract val ignoredPackages: ListProperty<String>

  /**
   * Classes to ignore.
   */
  @get:Input
  public abstract val ignoredClasses: ListProperty<String>

  /**
   * Project name (captured at configuration time for configuration cache compatibility).
   */
  @get:Input
  public abstract val projectName: Property<String>

  /**
   * Suffix to the generated stability file
   */
  @get:Input
  @get:Optional
  public abstract val stabilityFileSuffix: Property<String>

  init {
    group = "verification"
    description = "Dump composable stability information to stability file"
  }

  @TaskAction
  public fun dump() {
    val inputFile = stabilityInputFiles.singleOrNull()
    if (inputFile == null || !inputFile.exists()) {
      // If the file doesn't exist, it means the module has no composable functions
      // This is expected for modules like activities or utilities without composables
      logger.lifecycle("ℹ️  No composables found in :${projectName.get()}, skipping stability dump")
      return
    }

    val outputDirectory = outputDir.get().asFile
    outputDirectory.mkdirs()

    val stabilityFileName = if (stabilityFileSuffix.isPresent) {
      "${projectName.get()}-${stabilityFileSuffix.get()}"
    } else {
      projectName.get()
    }

    val outputFile = outputDirectory.resolve("$stabilityFileName.stability")
    val stabilityInfo = parseStabilityInfo(inputFile)
    val filtered = filterStabilityInfo(
      stabilityInfo,
      ignoredPackages.get(),
      ignoredClasses.get(),
    )

    writeStabilityFile(outputFile, filtered)

    logger.lifecycle("Stability file written to: ${outputFile.absolutePath}")
  }

  private fun parseStabilityInfo(file: java.io.File): List<StabilityEntry> {
    val content = file.readText()
    val entries = mutableListOf<StabilityEntry>()

    val composablesStart = content.indexOf("\"composables\": [")
    if (composablesStart == -1) return entries

    var pos = composablesStart + "\"composables\": [".length
    val endPos = content.lastIndexOf("]")

    while (pos < endPos) {
      val objStart = content.indexOf("{", pos)
      if (objStart == -1 || objStart > endPos) break

      val objEnd = findMatchingBrace(content, objStart)
      if (objEnd == -1) break

      val obj = content.substring(objStart, objEnd + 1)
      val entry = parseComposableObject(obj)
      if (entry != null) {
        entries.add(entry)
      }

      pos = objEnd + 1
    }

    return entries
  }

  private fun findMatchingBrace(text: String, start: Int): Int {
    var depth = 0
    var inString = false
    var escaped = false

    for (i in start until text.length) {
      val c = text[i]

      when {
        escaped -> escaped = false
        c == '\\' -> escaped = true
        c == '"' -> inString = !inString
        !inString && c == '{' -> depth++
        !inString && c == '}' -> {
          depth--
          if (depth == 0) return i
        }
      }
    }
    return -1
  }

  private fun parseComposableObject(obj: String): StabilityEntry? {
    val qualifiedName = extractJsonString(obj, "qualifiedName") ?: return null
    val simpleName = extractJsonString(obj, "simpleName") ?: return null
    val visibility = extractJsonString(obj, "visibility") ?: "public"
    val returnType = extractJsonString(obj, "returnType") ?: "Unit"
    val skippable = extractJsonBoolean(obj, "skippable") ?: false
    val restartable = extractJsonBoolean(obj, "restartable") ?: true

    val parameters = parseParameters(obj)

    return StabilityEntry(
      qualifiedName = qualifiedName,
      simpleName = simpleName,
      visibility = visibility,
      parameters = parameters,
      returnType = returnType,
      skippable = skippable,
      restartable = restartable,
    )
  }

  private fun parseParameters(obj: String): List<ParameterInfo> {
    val params = mutableListOf<ParameterInfo>()
    val paramsStart = obj.indexOf("\"parameters\": [")
    if (paramsStart == -1) return params

    var pos = paramsStart + "\"parameters\": [".length
    // Find matching ] for the parameters array, not just the first ]
    val paramsEnd = findMatchingBracket(obj, paramsStart + "\"parameters\": ".length)
    if (paramsEnd == -1) return params

    while (pos < paramsEnd) {
      val paramStart = obj.indexOf("{", pos)
      if (paramStart == -1 || paramStart > paramsEnd) break

      val paramEnd = findMatchingBrace(obj, paramStart)
      if (paramEnd == -1) break

      val paramObj = obj.substring(paramStart, paramEnd + 1)
      val name = extractJsonString(paramObj, "name") ?: ""
      val type = extractJsonString(paramObj, "type") ?: ""
      val stability = extractJsonString(paramObj, "stability") ?: "UNSTABLE"
      val reason = extractJsonString(paramObj, "reason")

      // Skip <this> parameter (extension receiver)
      if (name != "<this>") {
        params.add(
          ParameterInfo(
            name = name,
            type = type,
            stability = stability,
            reason = reason,
          ),
        )
      }

      pos = paramEnd + 1
    }

    return params
  }

  private fun findMatchingBracket(text: String, start: Int): Int {
    var depth = 0
    var inString = false
    var escaped = false

    for (i in start until text.length) {
      val c = text[i]

      when {
        escaped -> escaped = false
        c == '\\' -> escaped = true
        c == '"' -> inString = !inString
        !inString && c == '[' -> depth++
        !inString && c == ']' -> {
          depth--
          if (depth == 0) return i
        }
      }
    }
    return -1
  }

  private fun extractJsonString(json: String, key: String): String? {
    val pattern = "\"$key\":\\s*\"([^\"]*)\""
    val regex = pattern.toRegex()
    val match = regex.find(json) ?: return null
    return match.groupValues[1].unescapeJson()
  }

  private fun extractJsonBoolean(json: String, key: String): Boolean? {
    val pattern = "\"$key\":\\s*(true|false)"
    val regex = pattern.toRegex()
    val match = regex.find(json) ?: return null
    return match.groupValues[1].toBoolean()
  }

  private fun String.unescapeJson(): String {
    return this
      .replace("\\\\", "\\")
      .replace("\\\"", "\"")
      .replace("\\n", "\n")
      .replace("\\r", "\r")
      .replace("\\t", "\t")
  }

  private fun filterStabilityInfo(
    entries: List<StabilityEntry>,
    ignoredPackages: List<String>,
    ignoredClasses: List<String>,
  ): List<StabilityEntry> {
    return entries.filter { entry ->
      val packageName = entry.qualifiedName.substringBeforeLast('.', "")
      val className = entry.qualifiedName.substringAfterLast('.')

      // Filter out compiler-generated anonymous composables
      !entry.qualifiedName.contains("<anonymous>") &&
        !ignoredPackages.any { packageName.startsWith(it) } &&
        !ignoredClasses.contains(className)
    }
  }

  private fun writeStabilityFile(
    file: java.io.File,
    entries: List<StabilityEntry>,
  ) {
    if (entries.isEmpty()) {
      if (file.exists()) {
        file.delete()
        logger.lifecycle("No composables found - removed ${file.name}")
      }
      return
    }

    file.bufferedWriter().use { writer ->
      writer.write("// This file was automatically generated by Compose Stability Analyzer\n")
      writer.write("// https://github.com/skydoves/compose-stability-analyzer\n")
      writer.write("//\n")
      writer.write("// Do not edit this file directly. To update it, run:\n")
      writer.write("//   ./gradlew :${projectName.get()}:stabilityDump\n")
      writer.write("\n")

      entries.sortedBy { it.qualifiedName }.forEach { entry ->
        writer.write("@Composable\n")
        writer.write("${entry.visibility} fun ${entry.qualifiedName}(")
        writer.write(entry.parameters.joinToString(", ") { "${it.name}: ${it.type}" })
        writer.write("): ${entry.returnType}\n")
        writer.write("  skippable: ${entry.skippable}\n")
        writer.write("  restartable: ${entry.restartable}\n")
        writer.write("  params:\n")
        entry.parameters.forEach { param ->
          writer.write("    - ${param.name}: ${param.stability}")
          if (param.reason != null) {
            writer.write(" (${param.reason})")
          }
          writer.write("\n")
        }
        writer.write("\n")
      }
    }
  }
}

/**
 * Represents a composable function's stability information.
 */
internal data class StabilityEntry(
  val qualifiedName: String,
  val simpleName: String,
  val visibility: String,
  val parameters: List<ParameterInfo>,
  val returnType: String,
  val skippable: Boolean,
  val restartable: Boolean,
)

/**
 * Represents a parameter's stability information.
 */
internal data class ParameterInfo(
  val name: String,
  val type: String,
  val stability: String, // STABLE, UNSTABLE, RUNTIME
  val reason: String? = null,
)
